shader copy: ###################################################################
  versions:
    u8  SCHRO_OPENGL_SHADER_COPY_U8
    s16 SCHRO_OPENGL_SHADER_COPY_S16

  func void main (void):
    u8:
      copy_source_u8 (gl_TexCoord[0].xy)

    s16:
      copy_source_s16 (gl_TexCoord[0].xy)



# FIXME: consider specialized float path, see old shader code
shader convert: ################################################################
  versions:
    u8_s16  SCHRO_OPENGL_SHADER_CONVERT_U8_S16
    s16_u8  SCHRO_OPENGL_SHADER_CONVERT_S16_U8
    u8_u8   SCHRO_OPENGL_SHADER_CONVERT_U8_U8
    s16_s16 SCHRO_OPENGL_SHADER_CONVERT_S16_S16

  func void main (void):
    u8_s16:
      write_u8 (cast_u8_s16 (read_source_s16 (gl_TexCoord[0].xy) + 128))

    s16_u8:
      write_s16 (cast_s16_u8 (read_source_u8 (gl_TexCoord[0].xy)) - 128)

    u8_u8:
      copy_source_u8 (gl_TexCoord[0].xy)

    s16_s16:
      copy_source_s16 (gl_TexCoord[0].xy)



shader convert_u8_yuyv: ########################################################
  versions:
    y4 SCHRO_OPENGL_SHADER_CONVERT_U8_Y4_YUYV
    u2 SCHRO_OPENGL_SHADER_CONVERT_U8_U2_YUYV
    v2 SCHRO_OPENGL_SHADER_CONVERT_U8_V2_YUYV

  func void main (void):
    y4:
      # round x coordinate down from texel center n.5 to texel edge n.0
      float x = floor (gl_TexCoord[0].x) / 2.0
      float y = gl_TexCoord[0].y

      # shift x coordinate from texel edge n.0 to texel center n.5
      vec2 coordinate = vec2 (floor (x) + 0.5, y)
      var4_u8 yuyv = read_yuyv_vec4_u8_raw (coordinate)

      if fract (x) < 0.25:
        write_u8_raw (yuyv.r)
      else:
        write_u8_raw (yuyv.b)

    (u2|v2):
      var4_u8 yuyv = read_yuyv_vec4_u8_raw (gl_TexCoord[0].xy)

    u2:
      write_u8_raw (yuyv.g)

    v2:
      write_u8_raw (yuyv.a)



shader convert_u8_uyvy: ########################################################
  versions:
    y4 SCHRO_OPENGL_SHADER_CONVERT_U8_Y4_UYVY
    u2 SCHRO_OPENGL_SHADER_CONVERT_U8_U2_UYVY
    v2 SCHRO_OPENGL_SHADER_CONVERT_U8_V2_UYVY

  func void main (void):
    y4:
      # round x coordinate down from texel center n.5 to texel edge n.0
      float x = floor (gl_TexCoord[0].x) / 2.0
      float y = gl_TexCoord[0].y

      # shift x coordinate from texel edge n.0 to texel center n.5
      vec2 coordinate = vec2 (floor (x) + 0.5, y)
      var4_u8 uyvy = read_uyvy_vec4_u8_raw (coordinate)

      if fract (x) < 0.25:
        write_u8_raw (uyvy.g)
      else:
        write_u8_raw (uyvy.a)

    (u2|v2):
      var4_u8 uyvy = read_uyvy_vec4_u8_raw (gl_TexCoord[0].xy)

    u2:
      write_u8_raw (uyvy.r)

    v2:
      write_u8_raw (uyvy.b)



shader convert_u8_ayuv: ########################################################
  versions:
    y4 SCHRO_OPENGL_SHADER_CONVERT_U8_Y4_AYUV
    u4 SCHRO_OPENGL_SHADER_CONVERT_U8_U4_AYUV
    v4 SCHRO_OPENGL_SHADER_CONVERT_U8_V4_AYUV

  func void main (void):
    var4_u8 ayuv = read_ayuv_vec4_u8_raw (gl_TexCoord[0].xy)

    y4:
      write_u8_raw (ayuv.g)

    u4:
      write_u8_raw (ayuv.b)

    v4:
      write_u8_raw (ayuv.a)



shader convert_yuyv_u8_422: ####################################################
  versions:
    normal SCHRO_OPENGL_SHADER_CONVERT_YUYV_U8_422

  func void main (void):
    # round x coordinate down from texel center n.5 to texel edge n.0
    float x = floor (gl_TexCoord[0].x) * 2.0
    float y = gl_TexCoord[0].y

    # shift x coordinate from texel edge n.0 to texel center n.5
    vec2 coordinate1 = vec2 (x + 0.5, y)
    vec2 coordinate2 = vec2 (x + 1.5, y)
    var4_u8 yuyv

    yuyv.r = read_y4_u8_raw (coordinate1)
    yuyv.g = read_u2_u8_raw (gl_TexCoord[0].xy)
    yuyv.b = read_y4_u8_raw (coordinate2)
    yuyv.a = read_v2_u8_raw (gl_TexCoord[0].xy)

    write_vec4_u8_raw (yuyv)



shader convert_uyvy_u8_422: ####################################################
  versions:
    normal SCHRO_OPENGL_SHADER_CONVERT_UYVY_U8_422

  func void main (void):
    # round x coordinate down from texel center n.5 to n.0 and scale up to
    # double width
    float x = floor (gl_TexCoord[0].x) * 2.0
    float y = gl_TexCoord[0].y

    # shift x coordinate from texel edge n.0 to texel center n.5
    vec2 coordinate1 = vec2 (x + 0.5, y)
    vec2 coordinate2 = vec2 (x + 1.5, y)
    var4_u8 uyvy

    uyvy.r = read_u2_u8_raw (gl_TexCoord[0].xy)
    uyvy.g = read_y4_u8_raw (coordinate1)
    uyvy.b = read_v2_u8_raw (gl_TexCoord[0].xy)
    uyvy.a = read_y4_u8_raw (coordinate2)

    write_vec4_u8_raw (uyvy)



shader convert_ayuv_u8_444: ####################################################
  versions:
    normal SCHRO_OPENGL_SHADER_CONVERT_AYUV_U8_444

  func void main (void):
    var4_u8 ayuv

    ayuv.r = convert_raw_u8 (var_u8 (255))
    ayuv.g = read_y4_u8_raw (gl_TexCoord[0].xy)
    ayuv.b = read_u4_u8_raw (gl_TexCoord[0].xy)
    ayuv.a = read_v4_u8_raw (gl_TexCoord[0].xy)

    write_vec4_u8_raw (ayuv)



# FIXME: consider specialized float path, see old shader code
# FIXME: CPU overflows, GPU clamps, is this a problem?
shader add_s16_u8: #############################################################
  versions:
    normal SCHRO_OPENGL_SHADER_ADD_S16_U8

  defines:
    XY gl_TexCoord[0].xy

  func void main (void):
    write_s16 (read_source1_s16 (XY) + cast_s16_u8 (read_source2_u8 (XY)))



# FIXME: consider specialized float path, see old shader code
# FIXME: CPU overflows, GPU clamps, is this a problem?
shader add_s16_s16: ############################################################
  versions:
    normal SCHRO_OPENGL_SHADER_ADD_S16_S16

  defines:
    XY gl_TexCoord[0].xy

  func void main (void):
    write_s16 (read_source1_s16 (XY) + read_source2_s16 (XY))



# FIXME: consider specialized float path, see old shader code
# FIXME: CPU overflows, GPU clamps, is this a problem?
shader subtract_s16_u8: ########################################################
  versions:
    normal SCHRO_OPENGL_SHADER_SUBTRACT_S16_U8

  defines:
    XY gl_TexCoord[0].xy

  func void main (void):
    write_s16 (read_source1_s16 (XY) - cast_s16_u8 (read_source2_u8 (XY)))



# FIXME: consider specialized float path, see old shader code
# FIXME: CPU overflows, GPU clamps, is this a problem?
shader subtract_s16_s16: #######################################################
  versions:
    normal SCHRO_OPENGL_SHADER_SUBTRACT_S16_S16

  defines:
    XY gl_TexCoord[0].xy

  func void main (void):
    write_s16 (read_source1_s16 (XY) - read_source2_s16 (XY))



# 1 = Deslauriers-Debuc (9,7)
# 2 = LeGall (5,3)
# 3 = Deslauriers-Debuc (13,7)
# 4 = Haar 0/1
# 5 = Fidelity
# 6 = Daubechies (9,7)
#
# offset = height / 2
#
# +---------------+                read for...
# |               |
# |       L       |                L'            H'
# |               |
# |             o | A[2 * n - 6]   - - - - ? ?   - - - - ? ?
# |             o | A[2 * n - 4]   - - - - ? ?   - - - - ? ?
# |             o | A[2 * n - 2]   - - - - ? ?   o - o - ? ?
# |          /> X | A[2 * n    ]   = = = = ? ?   X X X X ? ?
# |         /   o | A[2 * n + 2]   - - - - ? ?   o o o - ? ?
# |         |   o | A[2 * n + 4]   - - - - ? ?   o - o - ? ?
# |         |   o | A[2 * n + 6]   - - - - ? ?   - - - - ? ?
# |  offset |   o | A[2 * n + 8]   - - - - ? ?   - - - - ? ?
# |         |     |
# +---------|-----+                1 2 3 4 5 6   1 2 3 4 5 6
# |         |     |
# |         |   o | A[2 * n - 7]   - - - - ? ?   - - - - ? ?
# |         |   o | A[2 * n - 5]   - - - - ? ?   - - - - ? ?
# |         |   o | A[2 * n - 3]   - - o - ? ?   - - - - ? ?
# |         \   o | A[2 * n - 1]   o o o - ? ?   - - - - ? ?
# |          \> X | A[2 * n + 1]   X X X X ? ?   = = = = ? ?
# |             o | A[2 * n + 3]   - - o - ? ?   - - - - ? ?
# |             o | A[2 * n + 5]   - - - - ? ?   - - - - ? ?
# |             o | A[2 * n + 7]   - - - - ? ?   - - - - ? ?
# |               |
# |       H       |
# |               |
# +---------------+



shader iiwt_s16_filter_deslauriers_dubuc_9_7_lp: ###############################
  versions:
    normal SCHRO_OPENGL_SHADER_IIWT_S16_FILTER_DESLAURIERS_DUBUC_9_7_Lp

  defines:
    XY gl_TexCoord[0].xy

  uniforms:
    # distance between two corresponding texels from subbands L and H in texels
    vec2 offset # = vec2 (width / 2.0, 0.0) or vec2 (0.0, height / 2.0)
    vec2 decrease1

  func var_s16 filter (var_s16 h1m, var_s16 h0):
    return divide_s16 (h1m + h0 + 2, 4)

  func void main (void):
    var_s16 l0  = read_source_s16 (XY)                      # A[2 ∗ n]
    var_s16 h1m = read_source_s16 (XY + offset - decrease1) # A[2 ∗ n - 1]
    var_s16 h0  = read_source_s16 (XY + offset)             # A[2 ∗ n + 1]

    write_s16 (l0 - filter (h1m, h0))



shader iiwt_s16_filter_deslauriers_dubuc_9_7_hp: ###############################
  versions:
    normal SCHRO_OPENGL_SHADER_IIWT_S16_FILTER_DESLAURIERS_DUBUC_9_7_Hp

  defines:
    XY gl_TexCoord[0].xy

  uniforms:
    # distance between two corresponding texels from subbands L' and H in texels
    vec2 offset # = vec2 (width / 2.0, 0.0) or vec2 (0.0, height / 2.0)
    vec2 decrease1
    vec2 increase1
    vec2 increase2

  func var_s16 filter (var_s16 l1m, var_s16 l0, var_s16 l1p, var_s16 l2p):
    return divide_s16 (-l1m + 9 * (l0 + l1p) - l2p + 8, 16)

  func void main (void):
    var_s16 l1m = read_source_s16 (XY - offset - decrease1) # A[2 ∗ n - 2]
    var_s16 l0  = read_source_s16 (XY - offset)             # A[2 ∗ n]
    var_s16 l1p = read_source_s16 (XY - offset + increase1) # A[2 ∗ n + 2]
    var_s16 l2p = read_source_s16 (XY - offset + increase2) # A[2 ∗ n + 4]
    var_s16 h0  = read_source_s16 (XY)                      # A[2 ∗ n + 1]

    write_s16 (h0 + filter (l1m, l0, l1p, l2p))



shader iiwt_s16_filter_le_gall_5_3_lp: #########################################
  versions:
    normal SCHRO_OPENGL_SHADER_IIWT_S16_FILTER_LE_GALL_5_3_Lp

  defines:
    XY gl_TexCoord[0].xy

  uniforms:
    # distance between two corresponding texels from subbands L and H in texels
    vec2 offset # = vec2 (width / 2.0, 0.0) or vec2 (0.0, height / 2.0)
    vec2 decrease1

  func var_s16 filter (var_s16 h1m, var_s16 h0):
    return divide_s16 (h1m + h0 + 2, 4)

  func void main (void):
    var_s16 l0  = read_source_s16 (XY)                      # A[2 ∗ n]
    var_s16 h1m = read_source_s16 (XY + offset - decrease1) # A[2 ∗ n - 1]
    var_s16 h0  = read_source_s16 (XY + offset)             # A[2 ∗ n + 1]

    write_s16 (l0 - filter (h1m, h0))



shader iiwt_s16_filter_le_gall_5_3_hp: #########################################
  versions:
    normal SCHRO_OPENGL_SHADER_IIWT_S16_FILTER_LE_GALL_5_3_Hp

  defines:
    XY gl_TexCoord[0].xy

  uniforms:
    # distance between two corresponding texels from subbands L and H in texels
    vec2 offset # = vec2 (width / 2.0, 0.0) or vec2 (0.0, height / 2.0)
    vec2 increase1

  func var_s16 filter (var_s16 l0, var_s16 l1p):
    return divide_s16 (l0 + l1p + 1, 2)

  func void main (void):
    var_s16 l0  = read_source_s16 (XY - offset)             # A[2 ∗ n]
    var_s16 l1p = read_source_s16 (XY - offset + increase1) # A[2 ∗ n + 2]
    var_s16 h0  = read_source_s16 (XY)                      # A[2 ∗ n + 1]

    write_s16 (h0 + filter (l0, l1p))



# FIXME: more than 1 level leads to errors
shader iiwt_s16_filter_deslauriers_dubuc_13_7_lp: ##############################
  versions:
    normal SCHRO_OPENGL_SHADER_IIWT_S16_FILTER_DESLAURIERS_DUBUC_13_7_Lp

  defines:
    XY gl_TexCoord[0].xy

  uniforms:
    # distance between two corresponding texels from subbands L and H in texels
    vec2 offset # = vec2 (width / 2.0, 0.0) or vec2 (0.0, height / 2.0)
    vec2 decrease2
    vec2 decrease1
    vec2 increase1

  func var_s16 filter (var_s16 h2m, var_s16 h1m, var_s16 h0, var_s16 h1p):
    return divide_s16 (-h2m + 9 * (h1m + h0) - h1p + 16, 32)

  func void main (void):
    var_s16 l0  = read_source_s16 (XY)                      # A[2 ∗ n]
    var_s16 h2m = read_source_s16 (XY + offset - decrease2) # A[2 ∗ n - 3]
    var_s16 h1m = read_source_s16 (XY + offset - decrease1) # A[2 ∗ n - 1]
    var_s16 h0  = read_source_s16 (XY + offset)             # A[2 ∗ n + 1]
    var_s16 h1p = read_source_s16 (XY + offset + increase1) # A[2 ∗ n + 3]

    write_s16 (l0 - filter (h2m, h1m, h0, h1p))



# FIXME: more than 1 level leads to errors
shader iiwt_s16_filter_deslauriers_dubuc_13_7_hp: ##############################
  versions:
    normal SCHRO_OPENGL_SHADER_IIWT_S16_FILTER_DESLAURIERS_DUBUC_13_7_Hp

  defines:
    XY gl_TexCoord[0].xy

  uniforms:
    # distance between two corresponding texels from subbands L and H in texels
    vec2 offset # = vec2 (width / 2.0, 0.0) or vec2 (0.0, height / 2.0)
    vec2 decrease1
    vec2 increase1
    vec2 increase2

  func var_s16 filter (var_s16 l1m, var_s16 l0, var_s16 l1p, var_s16 l2p):
    return divide_s16 (-l1m + 9 * (l0 + l1p) - l2p + 8, 16)

  func void main (void):
    var_s16 l1m = read_source_s16 (XY - offset - decrease1) # A[2 ∗ n - 2]
    var_s16 l0  = read_source_s16 (XY - offset)             # A[2 ∗ n]
    var_s16 l1p = read_source_s16 (XY - offset + increase1) # A[2 ∗ n + 2]
    var_s16 l2p = read_source_s16 (XY - offset + increase2) # A[2 ∗ n + 4]
    var_s16 h0  = read_source_s16 (XY)                      # A[2 ∗ n + 1]

    write_s16 (h0 + filter (l1m, l0, l1p, l2p))



shader iiwt_s16_filter_haar_lp: ################################################
  versions:
    normal SCHRO_OPENGL_SHADER_IIWT_S16_FILTER_HAAR_Lp

  uniforms:
    # distance between two corresponding texels from subbands L and H in texels
    vec2 offset # = vec2 (width / 2.0, 0.0) or vec2 (0.0, height / 2.0)

  func var_s16 filter (var_s16 h0):
    return divide_s16 (h0 + 1, 2)

  func void main (void):
    var_s16 l0 = read_source_s16 (gl_TexCoord[0].xy)          # A[2 ∗ n]
    var_s16 h0 = read_source_s16 (gl_TexCoord[0].xy + offset) # A[2 ∗ n + 1]

    write_s16 (l0 - filter (h0))



shader iiwt_s16_filter_haar_hp: ################################################
  versions:
    normal SCHRO_OPENGL_SHADER_IIWT_S16_FILTER_HAAR_Hp

  uniforms:
    # distance between two corresponding texels from subbands L' and H in texels
    vec2 offset # = vec2 (width / 2.0, 0.0) or vec2 (0.0, height / 2.0)

  func void main (void):
    var_s16 l0 = read_source_s16 (gl_TexCoord[0].xy - offset) # A[2 ∗ n]
    var_s16 h0 = read_source_s16 (gl_TexCoord[0].xy)          # A[2 ∗ n + 1]

    write_s16 (h0 + l0)



shader iiwt_s16_vertical_deinterleave: #########################################
  versions:
    l SCHRO_OPENGL_SHADER_IIWT_S16_VERTICAL_DEINTERLEAVE_L
    h SCHRO_OPENGL_SHADER_IIWT_S16_VERTICAL_DEINTERLEAVE_H

  uniforms:
    h:
      # height of subband XL
      vec2 offset # = vec2 (0.0, height / 2.0)

  func void main (void):
    float x = gl_TexCoord[0].x

    # round y coordinate down from texel center n.5 to texel edge n.0
    l:
      float y = floor (gl_TexCoord[0].y)

    h:
      float y = floor (gl_TexCoord[0].y) - offset.y

    # scale y coordinate to the destination coordinate and shift it from texel
    # edge n.0 to texel center n.5
    l:
      vec2 coordinate = vec2 (x, y * 2.0 + 0.5)

    h:
      vec2 coordinate = vec2 (x, y * 2.0 + 1.5)

    copy_source_s16 (coordinate)



shader iiwt_s16_interleave: ####################################################
  versions:
    vertical   SCHRO_OPENGL_SHADER_IIWT_S16_VERTICAL_INTERLEAVE
    horizontal SCHRO_OPENGL_SHADER_IIWT_S16_HORIZONTAL_INTERLEAVE

  uniforms:
    # vertical/horizontal distance between two corresponding texels from subband
    # XL/L' and XH/H' in texels
    vec2 offset # = vec2 (0.0, height / 2.0) or vec2 (width / 2.0, 0.0)

  func void main (void):
    vertical:
      float x = gl_TexCoord[0].x

      # round y coordinate down from texel center n.5 to texel edge n.0
      float y = floor (gl_TexCoord[0].y)

      if mod (y, 2.0) < 0.5:
        y = floor (y / 2.0)
      else:
        y = floor (y / 2.0) + offset.y

      # shift y coordinate from texel edge n.0 to texel center n.5
      vec2 coordinate = vec2 (x, y + 0.5)

    horizontal:
      # round x coordinate down from texel center n.5 to texel edge n.0
      float x = floor (gl_TexCoord[0].x)
      float y = gl_TexCoord[0].y

      if mod (x, 2.0) < 0.5:
        x = floor (x / 2.0)
      else:
        x = floor (x / 2.0) + offset.x

      # shift y coordinate from texel edge n.0 to texel center n.5
      vec2 coordinate = vec2 (x + 0.5, y)

    copy_source_s16 (coordinate)



shader iiwt_s16_filter_shift: ##################################################
  versions:
    normal SCHRO_OPENGL_SHADER_IIWT_S16_FILTER_SHIFT

  func void main (void):
    write_s16 (divide_s16 (read_source_s16 (gl_TexCoord[0].xy) + 1, 2))



shader upsample_u8: ############################################################
  versions:
    normal SCHRO_OPENGL_SHADER_UPSAMPLE_U8

  defines:
    XY gl_TexCoord[0].xy

  uniforms:
    vec2 decrease3
    vec2 decrease2
    vec2 decrease1
    vec2 increase1
    vec2 increase2
    vec2 increase3
    vec2 increase4

  func void main (void):
    var_s16 s3m = cast_s16_u8 (read_source_u8 (XY - decrease3)) # S[n - 3]
    var_s16 s2m = cast_s16_u8 (read_source_u8 (XY - decrease2)) # S[n - 2]
    var_s16 s1m = cast_s16_u8 (read_source_u8 (XY - decrease1)) # S[n - 1]
    var_s16 s0  = cast_s16_u8 (read_source_u8 (XY))             # S[n]
    var_s16 s1p = cast_s16_u8 (read_source_u8 (XY + increase1)) # S[n + 1]
    var_s16 s2p = cast_s16_u8 (read_source_u8 (XY + increase2)) # S[n + 2]
    var_s16 s3p = cast_s16_u8 (read_source_u8 (XY + increase3)) # S[n + 3]
    var_s16 s4p = cast_s16_u8 (read_source_u8 (XY + increase4)) # S[n + 4]
    var_s16 sum = divide_s16 (-s3m + 3 * s2m - 7 * s1m + 21 * s0 \
        + 21 * s1p - 7 * s2p + 3 * s3p - s4p + 16, 32)

    write_u8 (cast_u8_s16 (sum))



shader obmc_spatial_weight: ####################################################
  versions:
    normal SCHRO_OPENGL_SHADER_OBMC_SPATIAL_WEIGHT

  uniforms:
    var2_s16 block_offset # [xy]offset
    var2_s16 block_length # [xy]blen
    vec2 edge1            # edge condition: left, top
    vec2 edge2            # edge condition: right, bottom

  func var_s16 ramp (var_s16 coordinate, var_s16 block_offset):
    if block_offset == 1:
      if coordinate == 0:
        return 3
      else:
        return 5
    else:
      return 1 + divide_s16 (6 * coordinate + block_offset - 1, \
          2 * block_offset - 1)

  func var_s16 spatial_weight (var_s16 coordinate, var_s16 block_length, \
      var_s16 block_offset, vec2 edge):
    if block_offset == 0:
      return 8
    elif coordinate < 2 * block_offset:
      if edge.x > 0.5:
        return 8
      else:
        return ramp (coordinate, block_offset)
    elif block_length - 1 - coordinate < 2 * block_offset:
      if edge.y > 0.5:
        return 8
      else:
        return ramp (block_length - 1 - coordinate, block_offset)
    else:
      return 8

  func void main (void):
    # round coordinate down from texel center n.5 to texel edge n.0
    var2_s16 coordinate = var2_s16 (floor (gl_TexCoord[0].xy))
    var_s16 weight_x = spatial_weight (coordinate.x, block_length.x, \
        block_offset.x, vec2 (edge1.x, edge2.x))
    var_s16 weight_y = spatial_weight (coordinate.y, block_length.y, \
        block_offset.y, vec2 (edge1.y, edge2.y))

    write_s16 (weight_x * weight_y)



shader obmc_clear: #############################################################
  versions:
    normal SCHRO_OPENGL_SHADER_OBMC_CLEAR

  func void main (void):
    write_s16 (0)



shader obmc_shift: #############################################################
  versions:
    normal SCHRO_OPENGL_SHADER_OBMC_SHIFT

  func void main (void):
    write_s16 (divide_s16 (read_source_s16 (gl_TexCoord[0].xy) - 8160, 64))



shader obmc_render_dc: #########################################################
  versions:
    normal SCHRO_OPENGL_SHADER_OBMC_RENDER_DC

  defines:
    XY gl_TexCoord[0].xy

  uniforms:
    vec2 block_origin
    var_s16 dc

  func void main (void):
    var_s16 previous = read_previous_s16 (XY)
    var_s16 spatial_weight = read_spatial_weight_s16 (XY - block_origin)

    write_s16 (previous + dc * spatial_weight)



shader obmc_render_ref_prec: ###################################################
  versions:
    0_normal  SCHRO_OPENGL_SHADER_OBMC_RENDER_REF_PREC_0
    0_weight  SCHRO_OPENGL_SHADER_OBMC_RENDER_REF_PREC_0_WEIGHT
    3a_normal SCHRO_OPENGL_SHADER_OBMC_RENDER_REF_PREC_3a
    3a_weight SCHRO_OPENGL_SHADER_OBMC_RENDER_REF_PREC_3a_WEIGHT
    3b_normal SCHRO_OPENGL_SHADER_OBMC_RENDER_REF_PREC_3b
    3b_weight SCHRO_OPENGL_SHADER_OBMC_RENDER_REF_PREC_3b_WEIGHT

  defines:
    XY gl_TexCoord[0].xy

  uniforms:
    vec2 block_origin

    0_.*:
      vec2 offset

    3a_.*:
      vec2 offset1
      vec2 offset2

    3b_.*:
      vec2 offset1
      vec2 offset2
      vec2 offset3
      vec2 offset4
      var4_s16 linear_weight

  func void main (void):
    var_s16 previous = read_previous_s16 (XY)
    var_s16 spatial_weight = read_spatial_weight_s16 (XY - block_origin)
    var_s16 intermediate

    0_.*:
      intermediate = cast_s16_u8 (read_upsampled_u8 (XY + offset))

    3a_.*:
      var2_s16 upsampled

      upsampled.x = cast_s16_u8 (read_upsampled1_u8 (XY + offset1))
      upsampled.y = cast_s16_u8 (read_upsampled2_u8 (XY + offset2))

      intermediate = divide_s16 (crossfoot2_s16 (upsampled) + 1, 2)

    3b_.*:
      var4_s16 upsampled

      upsampled.x = cast_s16_u8 (read_upsampled1_u8 (XY + offset1))
      upsampled.y = cast_s16_u8 (read_upsampled2_u8 (XY + offset2))
      upsampled.z = cast_s16_u8 (read_upsampled3_u8 (XY + offset3))
      upsampled.w = cast_s16_u8 (read_upsampled4_u8 (XY + offset4))

      intermediate \
          = divide_s16 (crossfoot4_s16 (upsampled * linear_weight) + 8, 16)

    .*_normal:
      write_s16 (previous + intermediate * spatial_weight)

    .*_weight:
      write_s16 (previous + ref_weighting_s16 (intermediate) * spatial_weight)



shader obmc_render_biref_prec: #################################################
  versions:
    0_0_normal   SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_0_0
    0_0_weight   SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_0_0_WEIGHT
    0_3a_normal  SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_0_3a
    0_3a_weight  SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_0_3a_WEIGHT
    0_3b_normal  SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_0_3b
    0_3b_weight  SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_0_3b_WEIGHT
    3a_0_normal  SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_3a_0
    3a_0_weight  SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_3a_0_WEIGHT
    3a_3a_normal SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_3a_3a
    3a_3a_weight SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_3a_3a_WEIGHT
    3a_3b_normal SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_3a_3b
    3a_3b_weight SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_3a_3b_WEIGHT
    3b_0_normal  SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_3b_0
    3b_0_weight  SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_3b_0_WEIGHT
    3b_3a_normal SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_3b_3a
    3b_3a_weight SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_3b_3a_WEIGHT
    3b_3b_normal SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_3b_3b
    3b_3b_weight SCHRO_OPENGL_SHADER_OBMC_RENDER_BIREF_PREC_3b_3b_WEIGHT

  defines:
    XY gl_TexCoord[0].xy

  uniforms:
    vec2 block_origin

    0_.*:
      vec2 offset_ref1

    3a_.*:
      vec2 offset1_ref1
      vec2 offset2_ref1

    3b_.*:
      vec2 offset1_ref1
      vec2 offset2_ref1
      vec2 offset3_ref1
      vec2 offset4_ref1
      var4_s16 linear_weight_ref1

    .*_0_.*:
      vec2 offset_ref2

    .*_3a_.*:
      vec2 offset1_ref2
      vec2 offset2_ref2

    .*_3b_.*:
      vec2 offset1_ref2
      vec2 offset2_ref2
      vec2 offset3_ref2
      vec2 offset4_ref2
      var4_s16 linear_weight_ref2

  func void main (void):
    var_s16 previous = read_previous_s16 (XY)
    var_s16 spatial_weight = read_spatial_weight_s16 (XY - block_origin)
    var_s16 intermediate_ref1, intermediate_ref2, intermediate

    0_.*:
      intermediate_ref1 = cast_s16_u8 (read_upsampled_ref1_u8 (XY + offset_ref1))

    3a_.*:
      var2_s16 upsampled_ref1

      upsampled_ref1.x = cast_s16_u8 (read_upsampled1_ref1_u8 (XY + offset1_ref1))
      upsampled_ref1.y = cast_s16_u8 (read_upsampled2_ref1_u8 (XY + offset2_ref1))

      intermediate_ref1 = divide_s16 (crossfoot2_s16 (upsampled_ref1) + 1, 2)

    3b_.*:
      var4_s16 upsampled_ref1

      upsampled_ref1.x = cast_s16_u8 (read_upsampled1_ref1_u8 (XY + offset1_ref1))
      upsampled_ref1.y = cast_s16_u8 (read_upsampled2_ref1_u8 (XY + offset2_ref1))
      upsampled_ref1.z = cast_s16_u8 (read_upsampled3_ref1_u8 (XY + offset3_ref1))
      upsampled_ref1.w = cast_s16_u8 (read_upsampled4_ref1_u8 (XY + offset4_ref1))

      intermediate_ref1 = divide_s16 (crossfoot4_s16 (upsampled_ref1 \
          * linear_weight_ref1) + 8, 16)

    .*_0_.*:
      intermediate_ref2 = cast_s16_u8 (read_upsampled_ref2_u8 (XY + offset_ref2))

    .*_3a_.*:
      var2_s16 upsampled_ref2

      upsampled_ref2.x = cast_s16_u8 (read_upsampled1_ref2_u8 (XY + offset1_ref2))
      upsampled_ref2.y = cast_s16_u8 (read_upsampled2_ref2_u8 (XY + offset2_ref2))

      intermediate_ref2 = divide_s16 (crossfoot2_s16 (upsampled_ref2) + 1, 2)

    .*_3b_.*:
      var4_s16 upsampled_ref2

      upsampled_ref2.x = cast_s16_u8 (read_upsampled1_ref2_u8 (XY + offset1_ref2))
      upsampled_ref2.y = cast_s16_u8 (read_upsampled2_ref2_u8 (XY + offset2_ref2))
      upsampled_ref2.z = cast_s16_u8 (read_upsampled3_ref2_u8 (XY + offset3_ref2))
      upsampled_ref2.w = cast_s16_u8 (read_upsampled4_ref2_u8 (XY + offset4_ref2))

      intermediate_ref2 = divide_s16 (crossfoot4_s16 (upsampled_ref2 \
          * linear_weight_ref2) + 8, 16)

    .*_normal:
      intermediate = divide_s16 (intermediate_ref1 + intermediate_ref2 + 1, 2)

    .*_weight:
      intermediate = biref_weighting_s16 (intermediate_ref1, intermediate_ref2)

    write_s16 (previous + intermediate * spatial_weight)
