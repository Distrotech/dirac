#define SHADER_HEADER \
    "#version 110\n" \
    "#extension GL_ARB_draw_buffers : require\n" \
    "#extension GL_ARB_texture_rectangle : require\n"

#define SHADER_HEADER_INTEGER \
    "#version 120\n" \
    "#extension GL_ARB_draw_buffers : require\n" \
    "#extension GL_ARB_texture_rectangle : require\n" \
    "#extension GL_EXT_gpu_shader4 : require\n" \
    "#define uint unsigned int\n"



#define SHADER_READ_U8(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "float read"_postfix"_u8 (vec2 coordinate) {\n" \
    "  float fp = texture2DRect ("_texture", coordinate).r;\n" \
    /* scale from FP range [0..1] to U8 [0..255] range and apply proper
       rounding */ \
    "  return floor (fp * 255.0 + 0.5);\n" \
    "}\n"

#define SHADER_READ_U8_INTEGER(_texture, _postfix) \
    "uniform usampler2DRect "_texture";\n" \
    "uint read"_postfix"_u8 (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate).a;\n" \
    "}\n"

#define SHADER_READ_U8_RAW(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "float read"_postfix"_u8_raw (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate).r;\n" \
    "}\n"

#define SHADER_READ_U8_RAW_INTEGER(_texture, _postfix) \
    "uniform usampler2DRect "_texture";\n" \
    "uint read"_postfix"_u8_raw (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate).a;\n" \
    "}\n"

#define SHADER_READ_VEC4_U8(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "vec4 read"_postfix"_vec4_u8 (vec2 coordinate) {\n" \
    "  vec4 fp = texture2DRect ("_texture", coordinate);\n" \
    /* scale from FP range [0..1] to U8 range [0..255] and apply proper
       rounding */ \
    "  return floor (fp * 255.0 + vec4 (0.5));\n" \
    "}\n"

#define SHADER_READ_VEC4_U8_INTEGER(_texture, _postfix) \
    "uniform usampler2DRect "_texture";\n" \
    "uvec4 read"_postfix"_vec4_u8 (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate);\n" \
    "}\n"

#define SHADER_READ_VEC4_U8_RAW(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "vec4 read"_postfix"_vec4_u8_raw (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate);\n" \
    "}\n"

#define SHADER_READ_VEC4_U8_RAW_INTEGER(_texture, _postfix) \
    "uniform usampler2DRect "_texture";\n" \
    "uvec4 read"_postfix"_vec4_u8_raw (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate);\n" \
    "}\n"



#define SHADER_WRITE_U8 \
    "void write_u8 (float u8) {\n" \
    /* scale from U8 range [0..255] to FP range [0..1] */ \
    "  gl_FragColor = vec4 (u8 / 255.0);\n" \
    "}\n"

#define SHADER_WRITE_U8_INTEGER \
    "varying out uvec4 fragcolor_u8;\n" \
    "void write_u8 (uint u8) {\n" \
    "  fragcolor_u8 = uvec4 (u8);\n" \
    "}\n"

#define SHADER_WRITE_U8_RAW \
    "void write_u8_raw (float u8) {\n" \
    "  gl_FragColor = vec4 (u8);\n" \
    "}\n"

#define SHADER_WRITE_U8_RAW_INTEGER \
    "varying out uvec4 fragcolor_u8;\n" \
    "void write_u8_raw (uint u8) {\n" \
    "  fragcolor_u8 = uvec4 (u8);\n" \
    "}\n"

#define SHADER_WRITE_VEC4_U8 \
    "void write_vec4_u8 (vec4 u8) {\n" \
    /* scale from U8 range [0..255] to FP range [0..1] */ \
    "  gl_FragColor = u8 / 255.0;\n" \
    "}\n"

#define SHADER_WRITE_VEC4_U8_INTEGER \
    "varying out uvec4 fragcolor_u8;\n" \
    "void write_vec4_u8 (uvec4 u8) {\n" \
    "  fragcolor_u8 = u8;\n" \
    "}\n"

#define SHADER_WRITE_VEC4_U8_RAW \
    "void write_vec4_u8_raw (vec4 u8) {\n" \
    "  gl_FragColor = u8;\n" \
    "}\n"

#define SHADER_WRITE_VEC4_U8_RAW_INTEGER \
    "varying out uvec4 fragcolor_u8;\n" \
    "void write_vec4_u8_raw (uvec4 u8) {\n" \
    "  fragcolor_u8 = u8;\n" \
    "}\n"



#define SHADER_READ_S16(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "float read"_postfix"_s16 (vec2 coordinate) {\n" \
    "  float fp = texture2DRect ("_texture", coordinate).r;\n" \
    /* scale and bias from FP range [0..1] to S16 range [-32768..32767] */ \
    "  return floor (fp * 65535.0 + 0.5) - 32768.0;\n" \
    "}\n"

#define SHADER_READ_S16_INTEGER(_texture, _postfix) \
    "uniform isampler2DRect "_texture";\n" \
    "int read"_postfix"_s16 (vec2 coordinate) {\n" \
    /* bias from U16 range [0..65535] to S16 range [-32768..32767] */ \
    "  return texture2DRect ("_texture", coordinate).a - 32768;\n" \
    "}\n"

#define SHADER_READ_S16_RAW(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "float read"_postfix"_s16_raw (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate).r;\n" \
    "}\n"

#define SHADER_READ_S16_RAW_INTEGER(_texture, _postfix) \
    "uniform isampler2DRect "_texture";\n" \
    "int read"_postfix"_s16_raw (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate).a;\n" \
    "}\n"

#define SHADER_READ_VEC4_S16(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "vec4 read"_postfix"_vec4_s16 (vec2 coordinate) {\n" \
    "  vec4 fp = texture2DRect ("_texture", coordinate);\n" \
    /* scale and bias from FP range [0..1] to S16 range [-32768..32767] */ \
    "  return floor (fp * 65535.0 + vec4 (0.5)) - vec4 (32768.0);\n" \
    "}\n"

#define SHADER_READ_VEC4_S16_INTEGER(_texture, _postfix) \
    "uniform isampler2DRect "_texture";\n" \
    "ivec4 read"_postfix"_vec4_s16 (vec2 coordinate) {\n" \
    /* bias from U16 range [0..65535] to S16 range [-32768..32767] */ \
    "  return texture2DRect ("_texture", coordinate) - vec4 (32768.0);\n" \
    "}\n"

#define SHADER_READ_VEC4_S16_RAW(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "vec4 read"_postfix"_vec4_s16_raw (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate);\n" \
    "}\n"

#define SHADER_READ_VEC4_S16_RAW_INTEGER(_texture, _postfix) \
    "uniform isampler2DRect "_texture";\n" \
    "ivec4 read"_postfix"_vec4_s16_raw (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate);\n" \
    "}\n"



#define SHADER_WRITE_S16 \
    "void write_s16 (float s16) {\n" \
    /* bias and scale from S16 range [-32768..32767] to FP range [0..1] */ \
    "  gl_FragColor = vec4 ((s16 + 32768.0) / 65535.0);\n" \
    "}\n"

#define SHADER_WRITE_S16_INTEGER \
    "varying out ivec4 fragcolor_s16;\n" \
    "void write_s16 (int s16) {\n" \
    /* bias from S16 range [-32768..32767] to U16 range [0..65535] */ \
    "  fragcolor_s16 = ivec4 (s16 + 32768);\n" \
    "}\n"

#define SHADER_WRITE_S16_RAW \
    "void write_s16_raw (float s16) {\n" \
    "  gl_FragColor = vec4 (s16);\n" \
    "}\n"

#define SHADER_WRITE_S16_RAW_INTEGER \
    "varying out ivec4 fragcolor_s16;\n" \
    "void write_s16_raw (int s16) {\n" \
    "  fragcolor_s16 = ivec4 (s16);\n" \
    "}\n"

#define SHADER_WRITE_VEC4_S16 \
    "void write_vec4_s16 (vec4 s16) {\n" \
    /* bias and scale from S16 range [-32768..32767] to FP range [0..1] */ \
    "  gl_FragColor = (s16 + vec4 (32768.0)) / 65535.0;\n" \
    "}\n"

#define SHADER_WRITE_VEC4_S16_INTEGER \
    "varying out ivec4 fragcolor_s16;\n" \
    "void write_vec4_s16 (ivec4 s16) {\n" \
    /* bias from S16 range [-32768..32767] to U16 range [0..65535] */ \
    "  fragcolor_s16 = s16 + ivec4 (32768);\n" \
    "}\n"

#define SHADER_WRITE_VEC4_S16_RAW \
    "void write_vec4_s16_raw (vec4 s16) {\n" \
    "  gl_FragColor = s16;\n" \
    "}\n"

#define SHADER_WRITE_VEC4_S16_RAW_INTEGER \
    "varying out ivec4 fragcolor_s16;\n" \
    "void write_vec4_s16_raw (ivec4 s16) {\n" \
    "  fragcolor_s16 = s16;\n" \
    "}\n"



#define SHADER_COPY_U8(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "void copy"_postfix"_u8 (vec2 coordinate) {\n" \
    "  gl_FragColor = texture2DRect ("_texture", coordinate);\n" \
    "}\n"

#define SHADER_COPY_U8_INTEGER(_texture, _postfix) \
    "uniform usampler2DRect "_texture";\n" \
    "varying out uvec4 fragcolor_u8;\n" \
    "void copy"_postfix"_u8 (vec2 coordinate) {\n" \
    "  fragcolor_u8 = texture2DRect ("_texture", coordinate);\n" \
    "}\n"

#define SHADER_COPY_S16(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "void copy"_postfix"_s16 (vec2 coordinate) {\n" \
    "  gl_FragColor = texture2DRect ("_texture", coordinate);\n" \
    "}\n"

#define SHADER_COPY_S16_INTEGER(_texture, _postfix) \
    "uniform isampler2DRect "_texture";\n" \
    "varying out ivec4 fragcolor_s16;\n" \
    "void copy"_postfix"_s16 (vec2 coordinate) {\n" \
    "  fragcolor_s16 = texture2DRect ("_texture", coordinate);\n" \
    "}\n"



#define SHADER_CAST_S16_U8 \
    "float cast_s16_u8 (float u8) {\n" \
    "  return u8;\n" \
    "}\n"

#define SHADER_CAST_S16_U8_INTEGER \
    "int cast_s16_u8 (uint u8) {\n" \
    "  return int (u8);\n" \
    "}\n"

#define SHADER_CAST_U8_S16 \
    "float cast_u8_s16 (float s16) {\n" \
    "  return clamp (s16, 0.0, 255.0);\n" \
    "}\n"

#define SHADER_CAST_U8_S16_INTEGER \
    "uint cast_u8_s16 (int s16) {\n" \
    "  return uint (clamp (s16, 0, 255));\n" \
    "}\n"



#define SHADER_CONVERT_RAW_U8 \
    "float convert_raw_u8 (float u8) {\n" \
    /* scale from U8 range [0..255] to FP range [0..1] */ \
    "  return u8 / 255.0;\n" \
    "}\n"

#define SHADER_CONVERT_RAW_U8_INTEGER \
    "uint convert_raw_u8 (uint u8) {\n" \
    "  return u8;\n" \
    "}\n"

#define SHADER_CONVERT_RAW_S16 \
    "float convert_raw_s16 (float s16) {\n" \
    /* bias and scale from S16 range [-32768..32767] to FP range [0..1] */ \
    "  return (s16 + 32768.0) / 65535.0;\n" \
    "}\n"

#define SHADER_CONVERT_RAW_S16_INTEGER \
    "int convert_raw_s16 (int s16) {\n" \
    /* bias from S16 range [-32768..32767] to U16 range [0..65535] */ \
    "  return s16 + 32768;\n" \
    "}\n"



#define SHADER_DIVIDE_S16 \
    "float divide_s16 (float value, float divisor) {\n" \
    "  return floor (value / divisor);\n" \
    "}\n"

#if 0

#define SHADER_DIVIDE_S16_INTEGER \
    "int divide_s16 (int value, int divisor) {\n" \
    "  return value < 0\n" \
    "      ? (value - (divisor - ((-value) % divisor))) / divisor\n" \
    "      : value / divisor;\n" \
    "}\n"

#else

#define SHADER_DIVIDE_S16_INTEGER \
    "int divide_s16 (int value, int divisor) {\n" \
    "  return int (floor (float (value) / float (divisor)));\n" \
    "}\n"

#endif



#define SHADER_CROSSFOOT_S16 \
    "float crossfoot_s16 (vec4 value) {\n" \
    "  return value.r + value.g + value.b + value.a;\n" \
    "}\n"

#define SHADER_CROSSFOOT_S16_INTEGER \
    "int crossfoot_s16 (ivec4 value) {\n" \
    "  return value.r + value.g + value.b + value.a;\n" \
    "}\n"



#define SHADER_REF_WEIGHTING_S16 \
    "uniform float ref_weight1;\n" /* ref1_weight + ref2_weight */ \
    "uniform float ref_addend;\n" /* 1 << (ref_weight_precision - 1) */ \
    "uniform float ref_divisor;\n" /* 1 << ref_weight_precision */ \
    "float ref_weighting_s16 (float value) {\n" \
    "  return divide_s16 (value * ref_weight1 + ref_addend, ref_divisor);\n" \
    "}\n"

#define SHADER_REF_WEIGHTING_S16_INTEGER \
    "uniform float ref_weight1;\n" /* ref1_weight + ref2_weight */ /* FIXME: bind as int */ \
    "uniform float ref_addend;\n" /* 1 << (ref_weight_precision - 1) */ /* FIXME: bind as int */ \
    "uniform float ref_divisor;\n" /* 1 << ref_weight_precision */ /* FIXME: bind as int */ \
    "int ref_weighting_s16 (int value) {\n" \
    "  return divide_s16 (value * int (ref_weight1) + int (ref_addend),\n" \
    "      int (ref_divisor));\n" \
    "}\n"



#define SHADER_BIREF_WEIGHTING_S16 \
    "uniform float ref_weight1;\n" /* ref1_weight  */ \
    "uniform float ref_weight2;\n" /* ref2_weight */ \
    "uniform float ref_addend;\n" /* 1 << (ref_weight_precision - 1) */ \
    "uniform float ref_divisor;\n" /* 1 << ref_weight_precision */ \
    "float biref_weighting_s16 (float value1, float value2) {\n" \
    "  return divide_s16 (value1 * ref_weight1 + value2 * ref_weight2\n" \
    "      + ref_addend, ref_divisor);\n" \
    "}\n"

#define SHADER_BIREF_WEIGHTING_S16_INTEGER \
    "uniform float ref_weight1;\n" /* ref1_weight */ /* FIXME: bind as int */ \
    "uniform float ref_weight2;\n" /* ref2_weight */ /* FIXME: bind as int */ \
    "uniform float ref_addend;\n" /* 1 << (ref_weight_precision - 1) */ /* FIXME: bind as int */ \
    "uniform float ref_divisor;\n" /* 1 << ref_weight_precision */ /* FIXME: bind as int */ \
    "int biref_weighting_s16 (int value1, int value2) {\n" \
    "  return divide_s16 (value1 * int (ref_weight1)\n" \
    "      + value2 * int (ref_weight2) + int (ref_addend),\n" \
    "      int (ref_divisor));\n" \
    "}\n"



struct ShaderCode {
  int index;
  const char *name;
  const char *code;
  const char *code_integer;
};

