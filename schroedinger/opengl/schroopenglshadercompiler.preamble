#define SHADER_HEADER \
    "#version 110\n" \
    "#extension GL_ARB_draw_buffers : require\n" \
    "#extension GL_ARB_texture_rectangle : require\n"

#define SHADER_HEADER_INTEGER \
    "#version 120\n" \
    "#extension GL_ARB_draw_buffers : require\n" \
    "#extension GL_ARB_texture_rectangle : require\n" \
    "#extension GL_EXT_gpu_shader4 : require\n" \
    "#define uint unsigned int\n"

#define SHADER_READ_U8(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "float read"_postfix"_u8 (vec2 coordinate) {\n" \
    "  float fp = texture2DRect ("_texture", coordinate).r;\n" \
    /* scale from FP [0..1] to real U8 [0..255] and apply proper rounding */ \
    "  return floor (fp * 255.0 + 0.5);\n" \
    "}\n"

#define SHADER_READ_U8_INTEGER(_texture, _postfix) \
    "uniform usampler2DRect "_texture";\n" \
    "uint read"_postfix"_u8 (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate).a;\n" \
    "}\n"

#define SHADER_READ_RAW_U8(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "float read"_postfix"_raw_u8 (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate).r;\n" \
    "}\n"

#define SHADER_READ_RAW_U8_INTEGER(_texture, _postfix) \
    "uniform usampler2DRect "_texture";\n" \
    "uint read"_postfix"_raw_u8 (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate).a;\n" \
    "}\n"

#define SHADER_READ_U8_VEC4(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "vec4 read"_postfix"_u8_vec4 (vec2 coordinate) {\n" \
    "  vec4 fp = texture2DRect ("_texture", coordinate);\n" \
    /* scale from FP [0..1] to real U8 [0..255] and apply proper rounding */ \
    "  return floor (fp * 255.0 + vec4 (0.5));\n" \
    "}\n"

#define SHADER_READ_U8_VEC4_INTEGER(_texture, _postfix) \
    "uniform usampler2DRect "_texture";\n" \
    "uvec4 read"_postfix"_u8_vec4 (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate);\n" \
    "}\n"

#define SHADER_READ_RAW_U8_VEC4(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "vec4 read"_postfix"_u8_raw_vec4 (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate);\n" \
    "}\n"

#define SHADER_READ_RAW_U8_VEC4_INTEGER(_texture, _postfix) \
    "uniform usampler2DRect "_texture";\n" \
    "uvec4 read"_postfix"_raw_u8_vec4 (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate);\n" \
    "}\n"

#define SHADER_WRITE_U8 \
    "void write_u8 (float u8) {\n" \
    /* scale from real U8 [0..255] to FP [0..1] */ \
    "  gl_FragColor = vec4 (u8 / 255.0);\n" \
    "}\n"

#define SHADER_WRITE_U8_INTEGER \
    "varying out uvec4 fragcolor_u8;\n" \
    "void write_u8 (uint u8) {\n" \
    "  fragcolor_u8 = uvec4 (u8);\n" \
    "}\n"

#define SHADER_WRITE_RAW_U8 \
    "void write_raw_u8 (float u8) {\n" \
    "  gl_FragColor = vec4 (u8);\n" \
    "}\n"

#define SHADER_WRITE_RAW_U8_INTEGER \
    "varying out uvec4 fragcolor_u8;\n" \
    "void write_raw_u8 (uint u8) {\n" \
    "  fragcolor_u8 = uvec4 (u8);\n" \
    "}\n"

#define SHADER_WRITE_U8_VEC4 \
    "void write_u8_vec4 (vec4 u8) {\n" \
    /* scale from real U8 [0..255] to FP [0..1] */ \
    "  gl_FragColor = u8 / 255.0;\n" \
    "}\n"

#define SHADER_WRITE_U8_VEC4_INTEGER \
    "varying out uvec4 fragcolor_u8;\n" \
    "void write_u8_vec4 (uvec4 u8) {\n" \
    "  fragcolor_u8 = u8;\n" \
    "}\n"

#define SHADER_WRITE_RAW_U8_VEC4 \
    "void write_raw_u8_vec4 (vec4 u8) {\n" \
    "  gl_FragColor = u8;\n" \
    "}\n"

#define SHADER_WRITE_RAW_U8_VEC4_INTEGER \
    "varying out uvec4 fragcolor_u8;\n" \
    "void write_raw_u8_vec4 (uvec4 u8) {\n" \
    "  fragcolor_u8 = u8;\n" \
    "}\n"

#define SHADER_READ_S16(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "float read"_postfix"_s16 (vec2 coordinate) {\n" \
    /* scale and bias from FP range [0..1] to S16 range [-32768..32767] */ \
    "  return floor (texture2DRect ("_texture", coordinate).r\n" \
    "      * 65535.0 + 0.5) - 32768.0;\n" \
    "}\n"

#define SHADER_READ_S16_INTEGER(_texture, _postfix) \
    "uniform isampler2DRect "_texture";\n" \
    "int read"_postfix"_s16 (vec2 coordinate) {\n" \
    "  return texture2DRect ("_texture", coordinate).a - 32768;\n" \
    "}\n"

#define SHADER_WRITE_S16 \
    "void write_s16 (float s16) {\n" \
    /* scale and bias from S16 range [-32768..32767] to FP range [0..1] */ \
    "  gl_FragColor = vec4 ((s16 + 32768.0) / 65535.0);\n" \
    "}\n"

#define SHADER_WRITE_S16_INTEGER \
    "varying out ivec4 fragcolor_s16;\n" \
    "void write_s16 (int s16) {\n" \
    "  fragcolor_s16 = ivec4 (s16 + 32768);\n" \
    "}\n"

#define SHADER_COPY_U8(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "void copy"_postfix"_u8 (vec2 coordinate) {\n" \
    "  gl_FragColor (texture2DRect ("_texture", coordinate);\n" \
    "}\n"

#define SHADER_COPY_U8_INTEGER(_texture, _postfix) \
    "uniform usampler2DRect "_texture";\n" \
    "varying out uvec4 fragcolor_u8;\n" \
    "void copy"_postfix"_u8 (vec2 coordinate) {\n" \
    "  fragcolor_u8 = texture2DRect ("_texture", coordinate);\n" \
    "}\n"

#define SHADER_COPY_S16(_texture, _postfix) \
    "uniform sampler2DRect "_texture";\n" \
    "void copy"_postfix"_s16 (vec2 coordinate) {\n" \
    "  gl_FragColor (texture2DRect ("_texture", coordinate);\n" \
    "}\n"

#define SHADER_COPY_S16_INTEGER(_texture, _postfix) \
    "uniform isampler2DRect "_texture";\n" \
    "varying out ivec4 fragcolor_s16;\n" \
    "void copy"_postfix"_s16 (vec2 coordinate) {\n" \
    "  fragcolor_s16 = texture2DRect ("_texture", coordinate);\n" \
    "}\n"

#define SHADER_CAST_S16_U8 \
    "#define cast_s16_u8(_value) (_value)\n"

#define SHADER_CAST_S16_U8_INTEGER \
    "int cast_s16_u8 (uint u8) {\n" \
    "  return int (u8);\n" \
    "}\n"

#define SHADER_CAST_U8_S16 \
    "const float cast_u8_s16_min   =  32767.0          / 65535.0;\n" \
    "const float cast_u8_s16_max   = (32767.0 + 255.0) / 65535.0;\n" \
    "const float cast_u8_s16_scale =    255.0          / 65535.0;\n" \
    "const float cast_u8_s16_bias  = (32767.0 - 127.0) / 65535.0;\n" \
    "float cast_u8_s16 (float s16) {\n" \
    "  return clamp (s16, cast_u8_s16_min, cast_u8_s16_max)\n" \
    "      * cast_u8_s16_scale + cast_u8_s16_bias;\n" \
    "}\n"

#define SHADER_CAST_U8_S16_INTEGER \
    "uint cast_u8_s16 (int s16) {\n" \
    "  return uint (clamp (s16, 0, 255));\n" \
    "}\n"

#define SHADER_DIVIDE_S16 \
    "float divide_s16 (float value, float divisor) {\n" \
    "  return floor (value / divisor);\n" \
    "}\n"

#if 0

#define SHADER_DIVIDE_S16_INTEGER \
    "int divide_s16 (int value, int divisor) {\n" \
    "  return value < 0 ? (value - (divisor - ((-value) % divisor))) / divisor\n" \
    "      : value / divisor;\n" \
    "}\n"

#else

#define SHADER_DIVIDE_S16_INTEGER \
    "int divide_s16 (int value, int divisor) {\n" \
    "  return int (floor (float (value) / float (divisor)));\n" \
    "}\n"

#endif

#define SHADER_REF_WEIGHTING_S16 \
    "uniform float weight;\n" /* ref1_weight + ref2_weight */ \
    "uniform float addend;\n" /* 1 << (ref_weight_precision - 1) */ \
    "uniform float divisor;\n" /* 1 << ref_weight_precision */ \
    "float ref_weighting_s16 (float value) {\n" \
    "  return divide_s16 (value * weight + addend, divisor);\n" \
    "}\n"

#define SHADER_REF_WEIGHTING_S16_INTEGER \
    "uniform float weight;\n" /* ref1_weight + ref2_weight */ /* FIXME: bind as int */ \
    "uniform float addend;\n" /* 1 << (ref_weight_precision - 1) */ /* FIXME: bind as int */ \
    "uniform float divisor;\n" /* 1 << ref_weight_precision */ /* FIXME: bind as int */ \
    "int ref_weighting_s16 (int value) {\n" \
    "  return divide_s16 (value * int (weight) + int (addend), int (divisor));\n" \
    "}\n"

struct ShaderCode {
  int index;
  const char *name;
  const char *code;
  const char *code_integer;
};

