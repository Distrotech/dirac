#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#define SCHRO_ARITH_DEFINE_INLINE
#include <schroedinger/schro.h>
#include <schroedinger/schroasyncdecoder.h>

#include <liboil/liboil.h>
#include <schroedinger/schrooil.h>
#include <string.h>
#include <stdio.h>

static void schro_asyncdecoder_init (SchroAsyncDecoder *decoder);

SchroAsyncDecoder *schro_asyncdecoder_new()
{
  SchroAsyncDecoder *decoder;

  decoder = malloc(sizeof(SchroAsyncDecoder));
  memset (decoder, 0, sizeof(SchroAsyncDecoder));
  
  decoder->async = schro_async_new(0, NULL, NULL);

#ifdef SCHRO_GPU
  decoder->reference_queue = schro_queue_new (SCHRO_LIMIT_REFERENCE_FRAMES,
      (SchroQueueFreeFunc)schro_upsampled_gpuframe_free);
  schro_queue_alloc_freestack(decoder->reference_queue, UQUEUE_SIZE);
#else
  decoder->reference_queue = schro_queue_new (SCHRO_LIMIT_REFERENCE_FRAMES,
      (SchroQueueFreeFunc)schro_upsampled_frame_free);
#endif
      
  decoder->frame_queue = schro_queue_new (SCHRO_LIMIT_REFERENCE_FRAMES,
      (SchroQueueFreeFunc)schro_frame_unref);
  decoder->output_queue = schro_queue_new (SCHRO_LIMIT_REFERENCE_FRAMES,
      (SchroQueueFreeFunc)schro_frame_unref);


  return decoder;
}

void schro_asyncdecoder_free(SchroAsyncDecoder *decoder)
{
  schro_queue_free (decoder->output_queue);
  schro_queue_free (decoder->reference_queue);
  schro_queue_free (decoder->frame_queue);

  free(decoder);
}

void
schro_asyncdecoder_reset (SchroAsyncDecoder *decoder)
{
  schro_queue_clear (decoder->frame_queue);
  schro_queue_clear (decoder->reference_queue);
  schro_queue_clear (decoder->output_queue);

  decoder->have_access_unit = FALSE;
  decoder->next_frame_number = 0;
  decoder->have_frame_number = FALSE;

}

SchroVideoFormat *
schro_decoder_get_video_format (SchroAsyncDecoder *decoder)
{
  SchroVideoFormat *format;

  format = malloc(sizeof(SchroVideoFormat));
  memcpy (format, &decoder->settings.video_format, sizeof(SchroVideoFormat));

  return format;
}

void
schro_asyncdecoder_set_earliest_frame (SchroAsyncDecoder *decoder,
    SchroPictureNumber earliest_frame)
{
  decoder->earliest_frame = earliest_frame;
}

void
schro_asyncdecoder_set_skip_ratio (SchroAsyncDecoder *decoder, double ratio)
{
  if (ratio > 1.0) ratio = 1.0;
  if (ratio < 0.0) ratio = 0.0;
  decoder->skip_ratio = ratio;
}


SchroFrame *
schro_asyncdecoder_pull (SchroAsyncDecoder *decoder)
{
  SchroFrame *ret;

  SCHRO_DEBUG("searching for frame %d", decoder->next_frame_number);
  ret = schro_queue_remove (decoder->frame_queue, decoder->next_frame_number);
  if (ret) {
    decoder->next_frame_number++;
  }
  return ret;
}

void
schro_asyncdecoder_push (SchroAsyncDecoder *decoder, SchroBuffer *buffer)
{
  SCHRO_ASSERT(decoder->input_buffer == NULL);

  decoder->input_buffer = buffer;
}

int
schro_asyncdecoder_iterate (SchroAsyncDecoder *decoder)
{
  SchroDecoderParseHeader hdr;
  SchroDecoderPictureHeader pichdr;
  if (decoder->input_buffer == NULL) {
    return SCHRO_DECODER_NEED_BITS;
  }

  schro_unpack_init_with_data (&decoder->unpack, decoder->input_buffer->data,
      decoder->input_buffer->length, 1);

  schro_decoder_decode_parse_header(&hdr, &decoder->unpack);

  if (hdr.parse_code == SCHRO_PARSE_CODE_SEQUENCE_HEADER) {
    SCHRO_INFO ("decoding access unit");
    schro_decoder_decode_access_unit(&decoder->settings, &decoder->unpack);

    schro_buffer_unref (decoder->input_buffer);
    decoder->input_buffer = NULL;

    if (decoder->have_access_unit) {
      return SCHRO_DECODER_OK;
    }
    schro_asyncdecoder_init (decoder);
    decoder->have_access_unit = TRUE;
    return SCHRO_DECODER_FIRST_ACCESS_UNIT;
  }

  if (hdr.parse_code == SCHRO_PARSE_CODE_AUXILIARY_DATA) {
    int code;

    code = schro_unpack_decode_bits (&decoder->unpack, 8);

    if (code == SCHRO_AUX_DATA_MD5_CHECKSUM) {
      int i;
      for(i=0;i<16;i++){
        decoder->md5_checksum[i] = schro_unpack_decode_bits (&decoder->unpack, 8);
      }
      decoder->has_md5 = TRUE;
    }

    schro_buffer_unref (decoder->input_buffer);
    decoder->input_buffer = NULL;
    
    return SCHRO_DECODER_OK;
  }

  if (hdr.parse_code == SCHRO_PARSE_CODE_PADDING) {
    return SCHRO_DECODER_OK;
  }

  if (schro_decoder_is_end_sequence (decoder->input_buffer)) {
    SCHRO_INFO ("decoding end sequence");
    schro_buffer_unref (decoder->input_buffer);
    decoder->input_buffer = NULL;
    return SCHRO_DECODER_EOS;
  }

  if (!decoder->have_access_unit) {
    SCHRO_INFO ("no access unit -- dropping frame");
    schro_buffer_unref (decoder->input_buffer);
    decoder->input_buffer = NULL;
    return SCHRO_DECODER_OK;
  }

  if (schro_queue_is_empty (decoder->output_queue)) {
    return SCHRO_DECODER_NEED_FRAME;
  }
  
  schro_decoder_decode_picture_header(&pichdr, &decoder->unpack);

  if (!decoder->have_frame_number) {
    if (SCHRO_PARSE_CODE_NUM_REFS (hdr.parse_code) > 0) {
      SCHRO_ERROR("expected I frame after access unit header");
    }
    decoder->next_frame_number = pichdr.picture_number;
    decoder->have_frame_number = TRUE;
    SCHRO_INFO("next frame number after seek %d", decoder->next_frame_number);
  }

  /** Retiring */
  if (SCHRO_PARSE_CODE_IS_REFERENCE (decoder->parse_code)) {
      //schro_decoder_reference_retire (decoder, decoder->retired_picture_number);
      /** Mark reference for retirement.
          Should only be done if we're sure noone is using this anymore.
       */
      SCHRO_INFO("Need to retire frame %i", pichdr.retired_picture_number);
  }

  /// XXX picture
  /// todo
  SCHRO_ERROR("decode picture here --");

  return SCHRO_DECODER_OK;
}

void
schro_asyncdecoder_add_output_picture (SchroAsyncDecoder *decoder, SchroFrame *frame)
{
  schro_queue_add (decoder->output_queue, frame, 0);
}

/* reference pool */
#ifdef SCHRO_GPU
void
schro_asyncdecoder_reference_add (SchroAsyncDecoder *decoder, SchroUpsampledGPUFrame *frame,
    SchroPictureNumber picture_number)
#else
void
schro_asyncdecoder_reference_add (SchroAsyncDecoder *decoder, SchroUpsampledFrame *frame,
    SchroPictureNumber picture_number)
#endif
{
  SCHRO_DEBUG("adding %d", picture_number);

  if (schro_queue_is_full(decoder->reference_queue)) {
    schro_queue_pop (decoder->reference_queue);
  }
  schro_queue_add (decoder->reference_queue, frame, picture_number);
}

#ifdef SCHRO_GPU
SchroUpsampledGPUFrame *
schro_asyncdecoder_reference_get (SchroAsyncDecoder *decoder,
    SchroPictureNumber picture_number)
#else
SchroUpsampledFrame *
schro_asyncdecoder_reference_get (SchroAsyncDecoder *decoder,
    SchroPictureNumber picture_number)
#endif
{
  SCHRO_DEBUG("getting %d", picture_number);
  return schro_queue_find (decoder->reference_queue, picture_number);
}

void
schro_asyncdecoder_reference_retire (SchroAsyncDecoder *decoder,
    SchroPictureNumber picture_number)
{
  SCHRO_DEBUG("retiring %d", picture_number);
  schro_queue_delete (decoder->reference_queue, picture_number);
}

static void schro_asyncdecoder_init (SchroAsyncDecoder *decoder)
{
  /* We could send a message to subthreads to initialize here,
     as the video format is known now.
  */
}
